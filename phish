#!/usr/bin/python
from email.MIMEMultipart import MIMEMultipart
from email.MIMEText import MIMEText
from email.MIMEImage import MIMEImage
from random import randint
from string import Template
import argparse
import smtplib
import csv
import hashlib
import os
import binascii
import datetime

def attachments(email_dir):
    for root, dirs, files in os.walk(email_dir):
        for filename in files:
            if os.path.splitext(filename)[1] == ".png": 
                yield os.path.join(root, filename)

def new_salt(len=64):
    return binascii.hexlify(os.urandom(len))

def uid(email, salt =""):
	m = hashlib.sha512()
	m.update(salt + email)
	return m.hexdigest()

def timestamp(name, fmt='{name}=%Y-%m-%d-%H-%M-%S'):
    return datetime.datetime.now().strftime(fmt).format(name=name)

parser = argparse.ArgumentParser(description='Phish people')
parser.add_argument('-v', action="count", dest='verbose')
parser.add_argument('-c','--campaign',
	dest="campaign",
	help="Specifiy a tracking code for the campaign. If you provide one it is embedded in the uid of each user.",
	default = "TEST")
parser.add_argument('-e', '--email',
	dest="email_dir",
	help="Path to directory containing the elements of the phishing email. The directory should contain a html.txt file, a text.txt file, and attachements.",
	default = "bear-sample")
parser.add_argument('--tracker-html',
        dest="html_tracker",
        help="HTML to add to emails to track who opens the email",
        default='<p>P.S. We are tracking you[${uid}]!<img src="http://8.teachsecurity.com/tracking_pixel.png?uid=${uid}">')
parser.add_argument('-f','--victims-file',
        dest="victims_file",
        help="CSV file of template data. Email address should be in column titled 'email'.")
parser.add_argument('-d','--deliver',
	dest="simulate",
	help="Turn off simulation of sending emails and send emails",
	action='store_false',
	default=True)
parser.add_argument('-s', '--save-salt',
	dest="save_salt",
	help="Save the salt used to encode the UID",
	action="store_true",
	default = False)
parser.add_argument('-p', '--no-salt',
	dest="save_salt",
	help="Do not save the salt used to encode the UID",
	action="store_false")



args = parser.parse_args()
salt = new_salt()
print "Salt:" + salt
try:
	dirname = timestamp(args.campaign)
	os.makedirs(dirname)
	if args.save_salt:
		print "saving salt..."
		with open(dirname + "/salt.txt", 'w') as file_:
    			file_.write(salt)
except:
	print "Campaign already exists"
	exit()

smtp = smtplib.SMTP()

# Define these once; use them twice!
email_subject    = open(args.email_dir + "/subject.txt").read().rstrip('\r\n')
email_from_name  = open(args.email_dir + "/from_name.txt").read().rstrip('\r\n')
email_from_email = open(args.email_dir + "/from_email.txt").read().rstrip('\r\n')

if not args.simulate:
	smtpConnectStatus = smtp.connect('smtp.teachsecurity.com')
	#smtp.login('exampleuser', 'examplepass')
	print "Connect: " + str(smtpConnectStatus) 

victims = csv.DictReader(open(args.victims_file, 'r'))
for victim in victims:
	victim["uid"] = str(args.campaign) + "=" + uid(victim['email'], salt)

	# Create the root message and fill in the from, to, and subject headers
	msgRoot = MIMEMultipart('related')
	msgRoot['Subject'] = Template(email_subject).substitute(victim) 
	if args.verbose:
		print "Subject: " + msgRoot['Subject']
	msgRoot['From'] = Template(email_from_name).substitute(victim) + \
		 " <" + email_from_email + ">"
	msgRoot['To'] = victim['email']
	msgRoot.preamble = 'This is a multi-part message in MIME format.'

	# Encapsulate the plain and HTML versions of the message body in an
	# 'alternative' part, so message agents can decide which they want to display.
	msgAlternative = MIMEMultipart('alternative')
	msgRoot.attach(msgAlternative)

	textText = Template(open(args.email_dir + "/text.txt").read()).substitute(victim)
	msgText = MIMEText(textText)
	msgAlternative.attach(msgText)

	# We reference the image in the IMG SRC attribute by the ID we give it below
	htmlText = Template(open(args.email_dir + "/html.txt").read() + args.html_tracker).substitute(victim)
	if args.verbose==2:
		print htmlText
	msgText = MIMEText(htmlText, 'html')
	msgAlternative.attach(msgText)

	for attachment in attachments(args.email_dir):
		# This example assumes the image is in the current directory
		if args.verbose==2:
			print os.path.basename(attachment)
		fp = open(attachment, 'rb')
		msgImage = MIMEImage(fp.read())
		fp.close()
		# Define the image's ID as referenced above
		msgImage.add_header('Content-ID', '<' + os.path.basename(attachment) + '>')
		msgRoot.attach(msgImage)

	if not args.simulate:
		smtpSendStatus = smtp.sendmail(email_from_email, victim['email'], msgRoot.as_string())
	else:
		smtpSendStatus = "faked"
	if args.verbose==2:
		print msgRoot.as_string()

	print "To:" + msgRoot['To'] + " UID:" + victim["uid"] + " Send: " + str(smtpSendStatus)

if not args.simulate:
	smtp.quit()
